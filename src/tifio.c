/*
 * (c) Copyright 2015 - 2016 -- Anders Torger
 *
 * This program is open source. For license terms, see the LICENSE file.
 *
 */
#include <inttypes.h>
#include <sys/types.h>
#include <dirent.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>

#include <tiffio.h> // libtiff

#include <elog.h>
#include <wcompat.h>
#include <tifio.h>

const uint8_t matrix_letters_8x13[95][13] = {
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},// space :32
{0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},// ! :33
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36},
{0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18},
{0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70},
{0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e},
{0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c},
{0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30},
{0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03},
{0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e},
{0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06},
{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60},
{0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e},
{0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18},
{0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e},
{0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06},
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3},
{0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c},
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff},
{0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c},
{0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60},
{0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18},
{0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70},
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03},
{0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e},
{0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00},
{0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00},
{0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78},
{0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00},
{0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00},
{0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f},
{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
{0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00}};  // :126

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
#define UNUSED(x) (void)(x)

static float *
gauss_make_kernel(float radius,
                  int *row_count)
{
    int r = (int)ceil(radius);
    int rows = r*2+1;
    float *matrix = malloc(rows * sizeof(float));
    float sigma = radius/3;
    float sigma22 = 2*sigma*sigma;
    float sigmaPi2 = 2*M_PI*sigma;
    float sqrtSigmaPi2 = sqrt(sigmaPi2);
    float radius2 = radius*radius;
    float total = 0;
    int index = 0;
    int row, i;
    for (row = -r; row <= r; row++) {
        float distance = row*row;
        if (distance > radius2) {
            matrix[index] = 0;
        } else {
            matrix[index] = exp(-distance/sigma22) / sqrtSigmaPi2;
        }
        total += matrix[index];
        index++;
    }
    for (i = 0; i < rows; i++) {
        matrix[i] /= total;
    }
    *row_count = rows;
    return matrix;
}

static void
gauss_convtransp(double radius,
                 int width,
                 int height,
                 const uint16_t in[],
                 uint16_t out[])
{
    int cols;
    float *matrix = gauss_make_kernel(radius, &cols);
    const int cols2 = cols/2;

#pragma omp parallel for
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            float r = 0, g = 0, b = 0;
            int moffset = cols2;
            for (int col = -cols2; col <= cols2; col++) {
                float f = matrix[moffset+col];
                if (f == 0) {
                    continue;
                }
                int ix = x+col;
                if ( ix < 0 ) {
                    ix = 0;
                } else if ( ix >= width) {
                    ix = width-1;
                }
                r += f * (float)in[3*(y*width+ix)+0];
                g += f * (float)in[3*(y*width+ix)+1];
                b += f * (float)in[3*(y*width+ix)+2];
            }
            out[3*(x*height+y)+0] = (uint16_t)roundf(r);
            out[3*(x*height+y)+1] = (uint16_t)roundf(g);
            out[3*(x*height+y)+2] = (uint16_t)roundf(b);
        }
    }
    free(matrix);
}

static void
reference_rgb_gauss_blur(double radius,
                         int width,
                         int height,
                         const uint16_t in[],
                         uint16_t out[])
{
    uint16_t *buf = malloc(width * height * 3 * sizeof(buf[0]));

    gauss_convtransp(radius, width, height, in, buf);
    gauss_convtransp(radius, height, width, buf, out);
    free(buf);
}

static void
tiff_message_null(const char *module,
                  const char *format,
                  va_list error)
{
    UNUSED(module);
    UNUSED(format);
    UNUSED(error);
    // do nothing
}

static void
tiff_init(void)
{
    TIFFSetErrorHandler(tiff_message_null);
    TIFFSetWarningHandler(tiff_message_null);
}

static struct rgbimg *
tifio_img_load(const char filename[],
               int channel_count,
               bool error_is_fatal)
{
    struct rgbimg *img = NULL;
    tiff_init();
#if defined _WIN32
    wchar_t *fname = utf8to16(filename);
    TIFF *tif = TIFFOpenW(fname, "r");
    free(fname);
#else
    TIFF *tif = TIFFOpen(filename, "r");
#endif
    if (tif == NULL) {
        elog("Error: could not open \"%s\" for reading.\n", filename);
        goto fail;
    }
    uint32_t w, h;
    uint16_t bps, spp;
    if (TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w) == 0 ||
        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h) == 0 ||
        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps) == 0 ||
        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0)
    {
        elog("Error: missing required tag.\n");
        goto fail;
    }
    if ((bps != 8 && bps != 16) || spp != channel_count) {
        elog("Error: unexpected sample format, only 8 or 16 bit TIFF files with %d channels supported.\n", channel_count);
        goto fail;
    }
    img = malloc(sizeof(*img) + spp * w * h * sizeof(img->p[0]));
    img->w = w;
    img->h = h;
    size_t sls = TIFFScanlineSize(tif);
    if (sls != spp*w*bps/8) {
        elog("Error: unexpected scanline size.\n");
        goto fail;
    }
    uint8_t *p = malloc(sls * h);
    for (unsigned y = 0; y < h; y++) {
        if (bps == 16) {
            if (TIFFReadScanline(tif, &img->p[spp*w*y], y, 0) == -1) {
                free(p);
                goto fail;
            }
        } else {
            if (TIFFReadScanline(tif, p, y, 0) == -1) {
                free(p);
                goto fail;
            }
            for (unsigned i = 0; i < spp*w; i++) {
                img->p[spp*w*y+i] = (uint16_t)p[i] << 8;
            }
        }
    }
    free(p);
    TIFFClose(tif);

    return img;

fail:
    if (tif != NULL) TIFFClose(tif);
    free(img);
    if (error_is_fatal) exit(EXIT_FAILURE);
    return NULL;
}

struct rgbimg *
tifio_rgbimg_load(const char filename[],
                  bool error_is_fatal)
{
    return tifio_img_load(filename, 3, error_is_fatal);
}

bool
tifio_rgbimg_save(const char filename[],
                  const struct rgbimg *img,
                  enum tifio_colorspace colorspace,
                  bool error_is_fatal)
{
#if defined _WIN32
    wchar_t *fname = utf8to16(filename);
    TIFF *tif = TIFFOpenW(fname, "w");
    free(fname);
#else
    TIFF *tif = TIFFOpen(filename, "w");
#endif
    if (tif == NULL) {
        elog("Error: could not open \"%s\" for writing.\n", filename);
        goto fail;
    }
    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img->w);
    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img->h);
    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);
    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);
    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);
    if (colorspace == COLORSPACE_PROPHOTO) {
        static const uint8_t prophoto_icc[] =
            {
                0x00, 0x00, 0x03, 0xAC, 0x4B, 0x43, 0x4D, 0x53, 0x02, 0x10, 0x00, 0x00,
                0x6D, 0x6E, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5A, 0x20,
                0x07, 0xCE, 0x00, 0x0C, 0x00, 0x01, 0x00, 0x12, 0x00, 0x3A, 0x00, 0x15,
                0x61, 0x63, 0x73, 0x70, 0x4D, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00,
                0x4B, 0x4F, 0x44, 0x41, 0x52, 0x4F, 0x4D, 0x4D, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0xD6,
                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xD3, 0x2B, 0x4B, 0x4F, 0x44, 0x41,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
                0x63, 0x70, 0x72, 0x74, 0x00, 0x00, 0x01, 0x14, 0x00, 0x00, 0x00, 0x48,
                0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x01, 0x5C, 0x00, 0x00, 0x00, 0x83,
                0x77, 0x74, 0x70, 0x74, 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x14,
                0x72, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xF4, 0x00, 0x00, 0x00, 0x0E,
                0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xF4, 0x00, 0x00, 0x00, 0x0E,
		0x62, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xF4, 0x00, 0x00, 0x00, 0x0E,
		0x72, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x14,
		0x67, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x02, 0x18, 0x00, 0x00, 0x00, 0x14,
		0x62, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x02, 0x2C, 0x00, 0x00, 0x00, 0x14,
		0x64, 0x6D, 0x6E, 0x64, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x6E,
		0x64, 0x6D, 0x64, 0x64, 0x00, 0x00, 0x02, 0xB0, 0x00, 0x00, 0x00, 0xD1,
		0x6D, 0x6D, 0x6F, 0x64, 0x00, 0x00, 0x03, 0x84, 0x00, 0x00, 0x00, 0x28,
		0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x43, 0x6F, 0x70, 0x79,
		0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x45, 0x61,
		0x73, 0x74, 0x6D, 0x61, 0x6E, 0x20, 0x4B, 0x6F, 0x64, 0x61, 0x6B, 0x20,
		0x43, 0x6F, 0x6D, 0x70, 0x61, 0x6E, 0x79, 0x2C, 0x20, 0x31, 0x39, 0x39,
		0x39, 0x2C, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74,
		0x73, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2E, 0x00,
		0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D,
		0x50, 0x72, 0x6F, 0x50, 0x68, 0x6F, 0x74, 0x6F, 0x20, 0x52, 0x47, 0x42,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xFE, 0xFF, 0x00,
		0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x50, 0x00, 0x68, 0x00, 0x6F, 0x00,
		0x74, 0x00, 0x6F, 0x00, 0x20, 0x00, 0x52, 0x00, 0x47, 0x00, 0x42, 0x00,
		0x00, 0x00, 0x00, 0x0D, 0x50, 0x72, 0x6F, 0x50, 0x68, 0x6F, 0x74, 0x6F,
		0x20, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0xD6,
		0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xD3, 0x2C, 0x63, 0x75, 0x72, 0x76,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0xCD, 0x00, 0x00,
		0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x34,
		0x00, 0x00, 0x49, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x58, 0x59, 0x5A, 0x20,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x9C, 0x00, 0x00, 0xB6, 0x3E,
		0x00, 0x00, 0x00, 0x00, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0xD3, 0x2D,
		0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
		0x4B, 0x4F, 0x44, 0x41, 0x4B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x07, 0xFE, 0xFF, 0x00, 0x4B, 0x00, 0x4F, 0x00, 0x44, 0x00, 0x41,
		0x00, 0x4B, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4B, 0x4F, 0x44, 0x41, 0x4B,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x27, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63,
		0x65, 0x20, 0x4F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x4D, 0x65, 0x64,
		0x69, 0x75, 0x6D, 0x20, 0x4D, 0x65, 0x74, 0x72, 0x69, 0x63, 0x28, 0x52,
		0x4F, 0x4D, 0x4D, 0x29, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x28, 0xFE, 0xFF, 0x00, 0x52, 0x00, 0x65, 0x00, 0x66, 0x00,
		0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00,
		0x20, 0x00, 0x4F, 0x00, 0x75, 0x00, 0x74, 0x00, 0x70, 0x00, 0x75, 0x00,
		0x74, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x65, 0x00, 0x64, 0x00, 0x69, 0x00,
		0x75, 0x00, 0x6D, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x65, 0x00, 0x74, 0x00,
		0x72, 0x00, 0x69, 0x00, 0x63, 0x00, 0x28, 0x00, 0x52, 0x00, 0x4F, 0x00,
		0x4D, 0x00, 0x4D, 0x00, 0x29, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x00,
		0x00, 0x27, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x20,
		0x4F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x4D, 0x65, 0x64, 0x69, 0x75,
		0x6D, 0x20, 0x4D, 0x65, 0x74, 0x72, 0x69, 0x63, 0x28, 0x52, 0x4F, 0x4D,
		0x4D, 0x29, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6D, 0x6D, 0x6F, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10,
		0x00, 0x00, 0x9D, 0x03, 0x01, 0x01, 0x01, 0x01, 0xB0, 0xCF, 0x3B, 0x80,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
            };
        TIFFSetField(tif, TIFFTAG_ICCPROFILE, sizeof(prophoto_icc), prophoto_icc);
    }
    TIFFCheckpointDirectory(tif);

    for (int y = 0; y < img->h; y++) {
        TIFFWriteScanline(tif, (void *)&img->p[3*y*img->w], y, 0);
    }
    TIFFClose(tif);
    return true;
fail:
    if (tif != NULL) TIFFClose(tif);
    if (error_is_fatal) exit(EXIT_FAILURE);
    return false;
}

bool
tifio_get_transfer_function(const char filename[],
                            double *trc[3],
                            int *count_,
                            bool error_is_fatal)
{
    tiff_init();
#if defined _WIN32
    wchar_t *fname = utf8to16(filename);
    TIFF *tif = TIFFOpenW(fname, "r");
    free(fname);
#else
    TIFF *tif = TIFFOpen(filename, "r");
#endif
    if (tif == NULL) {
        elog("Error: could not open \"%s\".\n", filename);
        if (error_is_fatal) {
            exit(EXIT_FAILURE);
        }
        return false;
    }

    bool success = true;
    uint16_t *tab[3] = { NULL, NULL, NULL };
    while (TIFFGetField (tif, TIFFTAG_TRANSFERFUNCTION, &tab[0], &tab[1], &tab[2]) == 0 || tab[0] == NULL) {
        if (TIFFReadDirectory(tif) == 0) {
            success = false;
            break;
        }
    }
    if (success) {
        uint16_t bps;
        if (TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps) == 0) {
            bps = 8;
        }
        int count = 1 << bps;
        for (int i = 0; i < 3; i++) {
            trc[i] = malloc(count * sizeof(trc[i][0]));
            for (int j = 0; j < count; j++) {
                trc[i][j] = tab[i] == NULL ? trc[0][j] : (double)tab[i][j] / (count-1);
            }
        }
        *count_ = count;
    } else {
        *count_ = 0;
        trc[0] = trc[1] = trc[2] = NULL;
    }

    TIFFClose(tif);
    return true;
}

bool
tifio_flatfield_correct(const char orig_filename[],
                        const char ff_filename[],
                        const char out_filename[],
                        bool error_is_fatal)
{
    elog("Loading source image \"%s\"...\n", orig_filename);
    struct rgbimg *img = tifio_rgbimg_load(orig_filename, error_is_fatal);
    if (img == NULL) return false;
    elog("Loading flatfield image \"%s\"...\n", ff_filename);
    struct rgbimg *img_ff = tifio_rgbimg_load(ff_filename, error_is_fatal);
    if (img_ff == NULL) {
        free(img);
        if (error_is_fatal) exit(EXIT_FAILURE);
        return false;
    }

    if (img->w != img_ff->w || img->h != img_ff->h) {
        elog("Error: flatfield image doesn't have the same dimensions as the source image.\n");
        free(img);
        free(img_ff);
        if (error_is_fatal) exit(EXIT_FAILURE);
        return false;
    }


    const int w = img->w;
    const int h = img->h;

    elog("Applying some blur to flatfield image to kill any noise and dust...\n");
    {
        struct rgbimg *img_tmp = malloc(sizeof(*img_tmp) + w*h*3*sizeof(img_tmp->p[0]));
        *img_tmp = *img_ff;
        reference_rgb_gauss_blur(32, w, h, img_ff->p, img_tmp->p);
        free(img_ff);
        img_ff = img_tmp;
    }

    double avg[3] = {0,0,0};
    elog("Calculating the neutral for the flatfield image (= average over whole surface)...\n");
#pragma omp parallel for
    for (int y = 0; y < h; y++) {
        double avg_r[3] = {0,0,0};
        for (int x = 0; x < w; x++) {
            for (int c = 0; c < 3; c++) {
                avg_r[c] += img_ff->p[3*(w*y+x)+c] / 65535.0;
            }
        }
#pragma omp critical
        {
            avg[0] += avg_r[0];
            avg[1] += avg_r[1];
            avg[2] += avg_r[2];
        }
    }
    {
        for (int c = 0; c < 3; c++) avg[c] /= w * h;
        double mx = avg[0];
        for (int c = 0; c < 3; c++) if (avg[c] > mx) mx = avg[c];
        for (int c = 0; c < 3; c++) avg[c] /= mx;
    }
    elog("Applying flatfield correction to the source image (neutral: %f %f %f)...\n", avg[0], avg[1], avg[2]);
    float *p = malloc(3*img->w*img->h*sizeof(p[0]));
    float mx = 0;
#pragma omp parallel for
    for (int y = 0; y < h; y++) {
        const float f = 1.0 / 65535.0;
        float pmx = mx;
        for (int x = 0; x < w; x++) {
            for (int c = 0; c < 3; c++) {
                int o = 3*(w*y+x)+c;
                float v = img_ff->p[o] * f;
                float corr = v == 0 ? 1.0 : avg[c] / v;
                p[o] = corr * (img->p[o] * f);
                if (p[o] > pmx) {
                    // average with surroundings so it's not just a hot pixel
                    const int xd[] = {
                        +0, +0, -1, +1, +1, -1, +1, -1,
                        //-2, -2, -2, +2, +2, +2, -1, +0, +1, -1, +0, +1
                        //-3, -3, -3, +3, +3, +3, -1, +0, +1, -1, +0, +1, -2, +2, -2, +2
                    };
                    const int yd[] = {
                        -1, +1, +0, +0, +1, -1, -1, +1,
                        //-1, +0, +1, -1, +0, +1, -2, -2, -2, +2, +2, +2
                        //-1, +0, +1, -1, +0, +1, -3, -3, -3, +3, +3, +3, -2, +2, -2, +2
                    };
                    int count = 0;
                    uint32_t sum = 0;
                    for (int i = 0; i < (int)(sizeof(xd)/sizeof(xd[0])); i++) {
                        int x1 = x + xd[i]; int y1 = y + yd[i];
                        if (x1 < 0 || x1 >= w || y1 < 0 || y1 >= h) continue;
                        sum += img->p[3*(w*y1+x1)+c];
                        count++;
                    }
                    sum /= count;
                    float val = corr * (sum * f) * 1.05;
                    if (val > pmx) {
                        pmx = val;
                    }
                }
            }
        }
#pragma omp critical
        {
            if (pmx > mx) mx = pmx;
        }
    }
    free(img_ff);
#pragma omp parallel for
    for (int y = 0; y < h; y++) {
        const float f = 1.0 / mx;
        for (int x = 0; x < w; x++) {
            for (int c = 0; c < 3; c++) {
                float v = p[3*(w*y+x)+c] * f;
                if (v > 1.0) v = 1.0;
                img->p[3*(w*y+x)+c] = (uint16_t)roundf(v * 65535);
            }
        }
    }
    free(p);
    elog("Saving corrected image to \"%s\"...\n", out_filename);
    if (!tifio_rgbimg_save(out_filename, img, COLORSPACE_NONE, error_is_fatal)) {
        free(img);
        if (error_is_fatal) exit(EXIT_FAILURE);
        return false;
    }
    free(img);
    elog("Complete!\n");
    return true;
}

void
tifio_type(struct rgbimg *img,
           const char str[],
           uint16_t bg,
           uint16_t fg,
           int x1,
           int y1)
{
    int slen = strlen(str);
    for (int y = y1; y < img->h && y < y1 + 13; y++) {
        for (int x = x1; x < img->w && x < x1 + 9 * slen; x++) {
            uint8_t c = (uint8_t)str[(x - x1) / 9];
            if (c < 32) c = 32;
            if (c > 126) c = 32;
            c -= 32;
            c = matrix_letters_8x13[c][12 - (y - y1)];
            uint16_t v = bg;
            if (((uint32_t)c & (1 << (8 - ((x - x1) % 9)))) != 0) {
                v = fg;
            }
            img->p[3*(y*img->w+x)+0] = v;
            img->p[3*(y*img->w+x)+1] = v;
            img->p[3*(y*img->w+x)+2] = v;
        }
    }
}

#define bit_swap32(value)                                               \
    (((((uint32_t)(value)) & 0xFF000000) >> 24) |                       \
     ((((uint32_t)(value)) & 0x00FF0000) >>  8) |                       \
     ((((uint32_t)(value)) & 0x0000FF00) <<  8) |                       \
     ((((uint32_t)(value)) & 0x000000FF) << 24))

static bool
has_suffix(const char s[],
           const char suffix[])
{
    const char *p = strstr(s, suffix);
    if (!p) return false;
    return p[strlen(suffix)] == '\0';
}

struct spb_image *
tifio_spb_load(char filename[],
               int band_base,
               int band_width,
               bool error_is_fatal)
{
    char *files[4000];
    memset(files, 0, sizeof(files));
    FILE *stream = NULL;
    struct spb_image *spb = NULL;

    DIR *dir = opendir(filename);
    if (dir != NULL) {
        struct dirent *dirent;
        int band_count = 0;
        int max_band = -1;
        int min_band = 100000000;
        bool did_fail = false;
        while ((dirent = readdir(dir)) != NULL) {
            const char *name = dirent->d_name;
            if (has_suffix(name, ".tif") || has_suffix(name, ".tiff") || has_suffix(name, ".TIF") || has_suffix(name, ".TIFF")) {
                int band = -1;
                for (int i = 0; name[i] != '\0'; i++) {
                    if (isdigit(name[i])) {
                        band = atoi(&name[i]);
                        break;
                    }
                }
                if (band == -1) {
                    elog("Bad band in file \"%s\".\n", name);
                    did_fail = true;
                    break;
                }
                if (band_base > 0) {
                    band = band_base + band * band_width;
                }
                char path[strlen(filename) + strlen(name) + 32];
                sprintf(path, "%s/%s", filename, name);
                if (band < 0 || (size_t)band > sizeof(files)/sizeof(files[0])) {
                    elog("Band out of range in file \"%s\".\n", name);
                    did_fail = true;
                    break;
                }
                if (files[band] != NULL) {
                    elog("Duplicate band %d.\n", band);
                    did_fail = true;
                    break;
                }
                files[band] = strdup(path);
                if (band < min_band) min_band = band;
                if (band > max_band) max_band = band;
                band_count++;
            }
        }
        closedir(dir);

        if (did_fail) {
            goto fail;
        }
        int spacing = -1;
        struct rgbimg *img = tifio_img_load(files[min_band], 1, false);
        if (img == NULL) {
            goto fail;
        }
        int height = img->w;
        int width = img->h;
        int prev_band = min_band;
        for (int i = min_band+1; i <= max_band; i++) {
            if (files[i] != NULL) {
                if (spacing == -1) {
                    spacing = i - prev_band;
                } else if (i - prev_band != spacing) {
                    elog("Uneven band spacing.\n");
                    free(img);
                    goto fail;
                }
                prev_band = i;
            }
        }
        size_t data_size = width*height*band_count*sizeof(float);
        spb = malloc(sizeof(*spb) + data_size);
        spb->w = width;
        spb->h = height;
        spb->band_count = band_count;
        spb->band_spacing = spacing;
        spb->band_start = min_band;
        spb->band_end = max_band;
        elog("Spectral image \"%s\" is %d x %d pixels with %d bands %f to %f with %f nm spacing.\n",
                filename, width, height, band_count, spb->band_start, spb->band_end, spb->band_spacing);
        if (spb == NULL) {
            free(img);
            elog("out of memory.\n");
            goto fail;
        }
        for (int i = 0; i < band_count; i++) {
            int band = min_band + i * spacing;
            if (i > 0) {
                img = tifio_img_load(files[band], 1, false);
                if (img == NULL) {
                    goto fail;
                }
            }
            if (img->w != height || img->h != width) {
                elog("Mismatching image size\n");
                free(img);
                goto fail;
            }
            for (uint32_t y = 0; y < spb->h; y++) {
                for (uint32_t x = 0; x < spb->w; x++) {
                    spb->p[spb->w * spb->h * i + (spb->w * y + x)] = img->p[img->w*x+y] / 65535.0;
                }
            }
            free(files[band]); files[band] = NULL;
            free(img);
        }
        return spb;
    }

    stream = utf8_fopen(filename, "rb");
    if (stream == NULL) {
        elog("Could not open \"%s\" for reading: %s.\n", filename, strerror(errno));
        if (error_is_fatal) exit(EXIT_FAILURE);
        return NULL;
    }
    { // test SPB header
        uint8_t hdr[3];
        if (fread(hdr, 1, 3, stream) != 3) {
            elog("Could not read header.\n");
            goto fail;
        }
        if (hdr[0] != 'S' || hdr[1] != 'P' || hdr[2] != 'B') {
            elog("Invalid SPB header.\n");
            goto fail;
        }
    }
    bool do_swap;
    { // test if we need to swap data to get host order (file is always little endian)
        uint16_t t = 1;
        uint8_t bo[2];
        memcpy(bo, &t, 2);
        if (bo[1] == 1) {
            do_swap = true;
        } else {
            do_swap = false;
        }
    }
    uint32_t hdr32[6];
    if (fread(hdr32, 4, 6, stream) != 6) {
        elog("failed to read header.\n");
        goto fail;
    }
    if (do_swap) {
        for (int i = 0; i < 6; i++) hdr32[i] = bit_swap32(hdr32[i]);
    }
    float hdrf[3];
    memcpy(hdrf, &hdr32[3], 3*4);
    const uint32_t width = hdr32[0];
    const uint32_t height = hdr32[1];
    const uint32_t band_count = hdr32[2];
    size_t data_size = width*height*band_count*sizeof(float);
    spb = malloc(sizeof(*spb) + data_size);
    if (spb == NULL) {
        elog("out of memory.\n");
        goto fail;
    }
    spb->w = width;
    spb->h = height;
    spb->band_count = band_count;
    spb->band_start = hdrf[0];
    spb->band_spacing = hdrf[1];
    spb->band_end = hdrf[2];
    if (fread(spb->p, 1, data_size, stream) != data_size) {
        elog("failed to read image data.\n");
        goto fail;
    }
    fclose(stream);
    stream = NULL;
    if (do_swap) {
        uint32_t *p32 = (uint32_t *)spb->p;
        for (size_t i = 0; i < data_size/sizeof(float); i++) p32[i] = bit_swap32(p32[i]);
    }
    elog("Spectral image \"%s\" is %d x %d pixels with %d bands %f to %f with %f nm spacing.\n",
            filename, width, height, band_count, spb->band_start, spb->band_end, spb->band_spacing);
    return spb;

 fail:
    elog("Error: could read SPB spectral image from \"%s\".\n", filename);
    if (stream != NULL) {
        fclose(stream);
    }
    free(spb);
    for (size_t i = 0; i < sizeof(files)/sizeof(files[0]); i++) {
        free(files[i]);
    }
    if (error_is_fatal) exit(EXIT_FAILURE);
    return NULL;
}
